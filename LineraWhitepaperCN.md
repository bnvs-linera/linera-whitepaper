## Linera：为Web3 应用设计的高扩展性区块链基础设施
#### 版本2 - 2023年8月16日
### 摘要

我们推出 Linera，旨在创建一个具有可预测的性能、安全性和响应速度的区块链基础设施，为要求更高服务能力的Web3应用提供服务。为此，Linera 通过引入一种基于弹性验证器的新型集成式多链范式解决了区块空间稀缺问题。Linera 将用户置于协议的核心位置，允许他们管理自己的链（称为微链）中的区块生成，以实现最佳性能。为了帮助 Web3 开发人员充分利用 Linera 基础设施，我们开发了一个丰富的、语言无关的多链编程模型。Linera 应用程序使用异步消息跨链通信。在同一个微链中，应用程序使用同步调用和临时会话（又名资源）进行组合。Linera 的早期SDK版本将使用Wasm虚拟机，并主要面向Rust开发者。Linera 基础设施基于委托权益证明（delegated Proof of Stake），使用最先进的经济激励措施和社区的大规模审计来确保可靠的去中心化。[[1](<> '法律免责声明：此文档及其内容不构成出售或要约购买任何代币的要约或招揽。我们发布此白皮书只是为了收到公众的反馈和评论。本文件中的任何内容都不应被理解或解释为对 Linera 基础设施或其代币（如果有）将如何发展、被利用或增值做出保证或承诺。Linera 仅概述其当前计划，这些计划可能会自行决定而发生更改，其成功将取决于许多超出其控制范围的因素。此类前瞻性陈述必然涉及已知和未知的风险，这些风险可能导致未来期间的实际绩效和结果与我们在本文档中描述或暗示的内容存在重大差异。Linera 没有义务更新其计划。无法保证文件中任何陈述的准确性，因为实际结果和未来事件可能与我们的描述或暗示存在重大差异。请勿过度依赖前瞻性陈述。')].

## 目录
1 [**概述**](<>)<br>
&ensp;1.1 [Web3对可预测性能和响应能力的需求](<>)<br>
&ensp;1.2 [区块空间稀缺问题](<>)<br>
&ensp;1.3 [现有方法的不足之处](<>)<br>
&ensp;1.4 [Linera的使命](<>)<br>
&ensp;1.5 [Linera项目概述](<>)<br>
&ensp;&ensp;1.5.1 [基于弹性验证器的集成多链系统](<>)<br>
&ensp;&ensp;1.5.2 [使多链编程成为主流](<>)<br>
&ensp;&ensp;1.5.3 [弹性验证器的可靠去中心化](<>)<br>
2 [**Linera多链协议**](<>)<br>
&ensp;2.1 [参与者：用户、验证者、链所有者](<>)<br>
&ensp;2.2 [安全模型](<>)<br>
&ensp;2.3 [符号标记](<>)<br>
&ensp;2.4 [微链](<>)<br>
&ensp;2.5 [跨链请求](<>)<br>
&ensp;2.6 [链状态](<>)<br>
&ensp;2.7 [区块执行](<>)<br>
&ensp;2.8 [客户端/验证器交互](<>)<br>
&ensp;2.9 [核心协议的扩展](<>)<br>
3 [**多链协议分析**](<>)<br>
&ensp;3.1 [响应能力](<>)<br>
&ensp;3.2 [可扩展性](<>)<br>
&ensp;3.3 [安全性](<>)<br>
4 [**使用Linera构建Web3应用程序**](<>)<br>
&ensp;4.1 [创建应用](<>)<br>
&ensp;4.2 [多链部署](<>)<br>
&ensp;4.3 [跨链通信](<>)<br>
&ensp;4.4 [局部可组合性](<>)<br>
&ensp;4.5 [用户认证](<>)<br>
&ensp;4.6 [临时链](<>)<br>
5 [**去中心化**](<>)<br>
&ensp;5.1 [委托权益证明](<>)<br>
&ensp;5.2 [审计](<>)<br>
6 [**结论**](<>)<br>
A [**跨链通信**](<>)<br>
&ensp;A.1 [消息和收件箱](<>)<br>
&ensp;A.2 [跨链请求和发件箱](<>)<br>

## 1 概述
### 1.1 Web3对可预测性能和响应能力的需求

得益于区块链技术的发展，下一代互联网(Web3)将为用户提供新一代资产感知应用，使他们在数字经济中拥有更多的民主权利。然而，开发具有良好用户体验的Web3应用目前是一项具有挑战的任务，其中一个问题是规模应用的可靠性和响应能力：当太多用户活跃时，区块链可能停止响应或需要支付昂贵的交易费。总体而言，应用开发者希望他们的基础设施编程接口易于使用且可预测，不受其他应用程序的流量干扰。业内已经存在集中式API提供者来简化在流行的区块链上进行编程的过程，但使用者需要信任API提供者，同时也不能改善底层区块链的性能并降低费用。Linera旨在通过提供保证规模应用的性能和响应能力的基础设施来缩小集中式和去中心化应用之间的差距。

### 1.2 区块空间稀缺问题

传统区块链中，无法预测交易手续费和延迟的最坏情况， 主要原因可以解释为区块空间稀缺问题。换句话说，在只包含一条链的区块链中，发起交易的用户之间需要竞争将交易包含到下一个区块的机会，然而区块的生产速率和大小受到共识协议、网络和执行层性能的限制，在交易高峰期（例如NFT空投）期间，用户的交易可能因为其他用户的手续费出价远远超过其定价范围而失败，或延迟很长时间才能被确认—在此期间，基础设施对他们实际上是不可用的。

### 1.3 现有方法的不足之处

毫无疑问，多年来已经提出了许多以提高可扩展性为目标的区块链基础架构。在这里，我们对常见方法进行概要总结，而不试图详尽。

**更快的单链**。单链中的区块生产速度通常受验证者之间数据传播延迟的限制。早前，为了在满足安全需求和网络约束的条件下达成更高TPS，区块大小是第一个被调整的参数。得益于拜占庭容错（BFT）共识协议的最新进展，今天TPS的新瓶颈看起来是交易的顺序执行而不是共识排序（从消息池中选择合适的交易进入区块以待确认）。

我们可以预见的是，一个区块中包含的许多交易应该是相互独立的（译者注：这并不意味着一个区块中包含的所有交易都是相互独立的，仅表明大部分交易相互独立。例如，同一账号在一个区块内发送两次转账交易，则这两次转账交易并不独立，但该账号所有交易与其他账号的交易在本区块内是独立的）。基于这样的预期，文献19中的一些最近出现的项目已经开发出将一个区块中的交易分成不同的子集并发执行的架构<a href='#References19'>[19]</a>。毫无疑问，上述并发执行架构能够大大提升TPS，但依赖这样的架构依然难以达成超过6位数的TPS。此外，并发执行结构的TPS很大程度上取决于每个区块中相互独立的交易比例<a href='#References26'>[26]</a>，然而发送交易的用户不能事先知道该交易将被哪一个区块打包，亦不知该区块中其他用户发送的交易是否相互独立，由此导致用户无法确认该交易的执行费用和执行延迟。

最后，在高TPS的区块链中，由于执行交易需要CPU（计算资源）具有较高的计算速度，交易数据同步需要较大的网络带宽，使得对验证者的审计变得更加困难。具体而言，通用硬件的计算速度和下载能力不足，不能快速重放交易，大部分只拥有通用硬件的社区成员因此不能便捷地参与验证者的审计。

**区块链分片**。解决区块链可扩展性的另一个流行方向是分片。这一技术将执行状态拆分为固定数量的平行链，每一条平行链由独立的验证者集合运行。

区块链分片技术到今天仍在不断改进，这项技术的演进也曾因为一些困难的挑战颇显波折。首先，不同平行链使用不同验证者集合的设计为区块链系统引入了安全妥协，攻击者无需攻击整个区块链系统，而只需要选择性攻击系统中最弱的环节（比如铸币）。其次，重组分片（即重新构造用户账户在不同平行链上的交易分布）是一项复杂的操作，其过程中涉及巨量的网络通信<a href='#References33'>[33]</a>。最后，当需要增加分片数量以达成更高的TPS，平行链之间的跨链消息数量也会随之增加<a href='#References26'>[26]</a>。由于平行链运行在独立的验证者集合，将会导致跨链消息延迟的显著增加，由此抵消了增加新的分片带来的益处[<a href='#References31'>31</a>, <a href='#References33'>33</a>]。

**Rollups**。最后，解决区块空间稀缺性问题的另一种流行方法是Rollups协议，通常基于Optimistic或有效性证明（也称为ZK rollup）实现<a href='#References11'>[11]</a>。从顶层设计来看，Optimistic和ZK Rollups都是Layer 2协议，他们在链下构建一系列大区块，这些大区块将在Layer 1执行、压缩和确认。不幸的是，在Optimistic和ZK Rollups两种场景下，Layer 1确认交易都需要大量的时间。Optimistic协议中解决争议（达成共识）需要几天的时间。ZK Rollups协议将许多Layer 2交易压缩，然后一次性提交到Layer 1确认，作为一条Layer 1交易支付gas。在实践中，为了达成严格的数据可用性，每个Layer 2区块需要耗费几个小时收集足够的Layer 2交易，计算有效性证明并归档交易。

由于Layer 1过长的确认时间，某些对于可响应性要求较高且能接受分片带来的安全妥协的应用选择信任Layer 2的执行结果，这些应用必须信任Rollups协议能够持续运行（以保持活跃）以及公平地选择交易（参见Miner Extractable Value<a href='#References15'>[15]</a>），最新的去中心化Rollup协议设计亦充分体现了这样的担忧。

### 1.4 Our mission  我们的使命

受到这些洞见的启发，我们创建了Linera项目。该项目基于如下三个关键原则，开发一种新的Web3基础设施：

- (**i**) 构建一个具有可预测性能和响应能力的安全基础设施。为达成此目标，多条链将运行在同一组可扩展的弹性验证器上；

- (**ii**) 针对可扩展的Web3应用构建丰富的生态。为达成此目标，Linera引入新的执行层，多链编程在该执行层上是主流编程方法；

- (**iii**) 最大程度去中心化。为达成此目标，弹性验证者将得到最佳激励，并由社区成员进行规模化审计。

### 1.5 Overview of the project  项目概况

对于区块链社区而言，Linera将致力于引入下述创新点。

#### 1.5.1 一种基于弹性验证器的集成式多链系统

我们的愿景是实现一个大规模Web3基础设施，基于该基础设施开发的应用具有可预测的性能和响应性。为此，我们开发了一种新的多链协议，该协议的设计目的在于将现代云基础设施应用到Web3领域：

- (**1**) 在Linera中，验证器与Web2中的弹性服务相似，验证器并行验证和执行多条链的区块中的交易。在Linera系统中，链(包括活跃的和非活跃的)的数量是无限的，我们也将这样的链称为微链。

- (**2**) 向微链添加新区块与交易的验证和执行是分离的，只有链的所有者(们)(译者注：此处原文为owner(s)，表示微链可以有一个或多个owner)能够添加新区块。每个Linera用户(译者注：此处user不仅指发起交易的人，也指与区块链交互的客户端)都可以创建自己的微链，用于管理他们自己的账户。

- (**3**) 每一个验证器都管理所有微链(我们称为集成式多链方法)。微链之间通过异步消息交互，或独立运行。这样的设计使得验证器可以将负载拆分到多个集群内部成员(即分片)，以实现弹性伸缩。微链之间凭借验证器的内部网络执行异步消息通信，以确保效率。

- (**4**) 微链有不同的方式接受新区块。在添加新区块时，用户通过低延迟、无内存池的可靠广播协议[<a href='#References7'>7</a>, <a href='#References12'>12</a>]将新区块提交给验证器。某些应用程序需要更加复杂的交互，可能会根据需要创建临时链。在实践中，只有Linera基础设施拥有的公共微链需要完整的BFT共识协议<a href='#References12'>[12]</a>。

- (**5**) 原则上，验证器之间不会相互交互——除了Linera基础设施拥有的公共微链。验证器之间的微链同步通过微链的所有者实现。这意味着对于验证者来说，不活跃的微型链（不创建区块的链）除了存储外没有额外成本。

弹性验证器是Linera的独特假设。我们致力于支持更多可以作为验证器的云服务提供商，供Linera社区选择。Linera最初受到Meta开发的低延迟支付协议FastPay启发，在此基础上，Linera将用户账户转换为微链、添加智能合约并支持微链之间任意异步消息通信，大大丰富了FastPay协议。Linera多链协议的更多详细描述请参见第<a href='#Section2'>2</a>节。我们将在第<a href='#Section3'>3</a>节分析该协议。

#### 1.5.2 使多链编程成为主流

Linera使用同一个验证者集合管理全部微链。大规模的跨链通信通过单个验证者的内部网络实现，Web3应用从此能够利用廉价高效的基础设施弹性扩容。为了推动多链编程的采用，我们做出了以下设计选择：

- (**6**) Linera的执行模型是编程语言无关的，且对开发者友好。初始版本的Linera SDK将基于Wasm，面向Rust编程语言。

- (**7**) Linera应用程序是组合式的多链应用。应用程序被创建后，可以按需在任何微链上运行。同一应用程序在不同的微链上有不同的运行实例，这些运行实例通过异步消息和发布/订阅频道通信。同一微链上的不同应用程序通过跨合约调用和临时会话对象进行交互。

Linera中的会话对象受到Move语言中资源的启发<a href='#References9'>[9]</a>。Move语言中的静态类型资源被提议用于帮助实现组合性。在Linera中，会话处理和运行时检查实现了类似资源的组合性。例如，要发送代币，Linera合约能够转移包含该代币的临时会话的所有权。

总的来说，构建大型开发者社区是区块链基础设施被采用的一个重要因素。鉴于Wasm生态对于多语言工具的持续改进<a href='#References4'>[4]</a>，我们认为Wasm能够支撑Linera长期服务于不同的开发者社区。我们将在第<a href='#Section4'>4</a>节讨论更详细的Linera编程模型。

#### 1.5.3 弹性验证者的可靠去中心化

经典的“区块链不可能三角”<a href='#References10'>[10]</a>阐述了同时实现扩展性、安全性和去中心化的困难。这样的的观点在验证器能力恒定的前提下确实成立，然而我们认为，对于如何定义和实施能够满足去中心化要求的弹性验证器这一方向，我们还没有做出足够的努力。

- (**8**) Linera依赖委托权益证明(DPoS)保障安全性，并支持定期更换验证者集合。得益于区块的链接，任何微链的历史交易、跨链消息和执行状态都是防篡改的。

- (**9**) 微链可以被独立审计。这意味着作为整体的Linera可以由社区进行分布式审计，社区成员仅需要通用硬件便可参与。

文献<a href='#References10'>[10]</a>在Roolups场景下讨论了使用高性能验证器，同时由社区驱动的审计保持去中心化。随着Linera项目进展，我们将继续关注有效性（“ZK”）证明和链压缩领域的技术进步。我们将在第<a href='#Section5'>5</a>节进一步讨论Linera的去中心化。

## 2 Linera多链协议

<a name='Section2'>我们</a>将在这一章介绍Linera基础设施的核心：多链协议。本章的主旨在于阐明该协议的主要思想，因此将不会对协议做详尽分析说明。我们将在第<a href='#Section3'>3</a>章中非正式地分析该协议，并在第<a href='#Section4'>4</a>章讨论编程模型。

### 2.1 参与者：用户、验证者、链所有者

Linera协议的目标，在于提供一个计算基础设施。应用开发者可以在该基础设施上创建dApps，终端用户可以安全高效地访问dApps。

和其他区块链系统一样，Linera应用程序的状态被复制到多个部分可信节点，这些节点称为验证者。应用程序通过将交易插入到新区块，并将新区块提交给验证者更新应用程序状态。

为了支持扩展性，Linera不再使用单链，取而代之的是集成式的多链系统。该系统拥有多条并行执行的链（称之为微链），交易被组织到这些并行执行的微链区块中。这意味着Linera应用程序的状态通常分布在不同的微链上。特别需要指出的是，除非正在进行重新配置(<a href='#Section2.9'>2.9</a>)，Linera中的所有微链都使用同一组验证器。

在Linera中，向区块链添加新区块与验证区块的任务是分离的，新区块由链的所有者创建。事实上，链的所有者可以是协议的任何参与者。由于Linera验证器负责验证区块，链的所有者可以只需要实现客户端功能即可。下面是一些链所有者的示例：

- 希望在不同应用程序中对自己的用户拥有更多控制权的终端用户；

- 希望运行临时链(例如用于原子交换)的终端用户；

- 希望将代码部署到链上以创建应用，或管理应用程序的开发者；

- 运行公开链的验证者(例如用于基础设施)。

最后，我们将阐述Linera如何管理当前验证者集(也称为委员会)。第<a href='#Section4'>4</a>章中我们将讨论Linera的编程模型，此外，审计员角色将在第<a href='#Section5'>5</a>章讨论。

### 2.2 安全模型

<a name='Section2.2'>Linera</a>的共识遵循拜占庭容错机制(BFT)<a href='#References13'>[13]</a>，所有参与者创建自己的钥密钥对。Linera使用委托权益证明（DPoS）模型，每个验证者的投票权与其直接质押份额和用户委托给该验证者的质押份额相关。

**假设**。我们以总投票权为*N*的例子来说明Linera协议。一组未知的*Byzantine* (即*dishonest*)验证者子集可能偏离协议，与许多BFT协议[<a href='#References7'>7</a>, <a href='#References13'>13</a>]相似，假设该验证者子集最多控制*f*的投票权，其中*f*的取值范围为*0* ≤ *f* < $\frac{ N }{ 3 }$。在实践中，人们通常选择最大值作为*f*，即*f* = $\lfloor \frac{ N - 1 }{ 3 } \rfloor$。

安全层面，我们不对用户、链所有者或网络层实现做任何假设。除非特别说明，否则可用性(译者注：原文这里为liveness，意指服务能响应请求，但翻译为活性、活跃性都不合适，因此我们意译为可用性)不依赖于网络延迟或消息顺序，换句话说，网络是*异步的*<a href='#References13'>[13]</a>。

我们用术语*quorum*(译者注：quorum英文释义为法定人数，但是在区块链场景使用这样的释义略显莫名其妙，因此此处我们保留原单词)来表示由一组验证者签发的签名集合，参与签名的验证者至少拥有*N - f*的投票权。对于任意两个*quorum*，如果同一个诚实的验证者*α*同时存在于两个*quorum*中，称为quorum*交集*，这是*quorum*的重要特性。一个*quorum*中的验证者对数据(通常为一个区块)进行签名，称之为*认证*，被认证过的数据简称为*证书*。

**目标**。Linera旨在确保下述安全特性：

- *安全性*：对于任意微链，不同的验证者看到的都是相同的区块(的前缀)按照同样顺路组成的链条，验证者按照同样的顺序修改微链的执行状态，并最终将同样的消息集合提交到其他微链。

- *微链的最终一致性*：当一个诚实的验证者认证了一个新的区块，并将其添加到微链上，任何用户都可以通过一系列步骤确保该区块被所有诚实的验证者添加到他们的微链上。

- *异步消息的最终一致性*：如果某个诚实的验证者上的微链收到了跨链消息，任何用户都可以通过一系列步骤确保该消息被所有诚实的验证者收到。

- *可靠性*：只有微链的所有者(们)能向微链添加区块。

- *分段可审计性*：Linera的状态有足够的公开加密证据，可以以微链为单位，分布式审计其正确性。

对于只有一个所有者的微链(第<a href='#Section2.4'>2.4</a>节)，Linera还确保以下特性：

- *单一区块验证*：在只有一个所有者的微链中，当所有者在给定高度签名并提交了该高度的第一个区块，只要有一个诚实的验证者接受该区块，那么通过适当的操作，所有者最终一定能够成功收集到足够的投票，为该区块生成一个证书。

- *最坏情况下的效率*：在只有一个所有者的微链中，拜占庭验证者不能给区块生成和正确用户的区块确认造成显著延迟。

### 2.3 符号

假设存在一个抗碰撞的哈希函数，记为**hash**(.)，以及一个安全的公钥签名方案**sign**(.)。一个*quorum*的所有验证者将对区块*B*签名，形成标记为*C* = **cert**[*B*]的证书。后续章节中，来自同一区块*B*的任意证书都将标记为*C* = **cert**[*B*]。

Linera 系统的状态被复制到所有验证者中。对于给定的验证者，记为 α，我们使用符号 X(α) 来表示关于某个复制数据 X 的验证者 α 的当前视图。数据类型 D = $\left \langle Tag, arg_1, . . . , arg_n \right \rangle$ 是一系列以独特标记 Tag 开头的值，并打算发送到网络上。我们使用大写名称来区分数据类型标记和数学函数（例如 hash）或数据字段（例如 owner(α)），并简单地写作**Tag**$(arg_1, . . . , arg_n)$ 表示一个数据类型。我们将 写作 $\widetilde{D}$ 表示一系列数据类型 $(D_1, . . . D_n)$。

Linera系统的执行状态将被所有验证者复制。对于给定的验证者*α*以及数据*X*，我们使用符号*X*(*α*)来表示 *α* 上的当前 *X* 视图。*data type D* =  $\left \langle Tag, arg_1, . . . , arg_n \right \rangle$ 是一系列以 **Tag** 开头并等待传输到网络上的值。区别于数学函数(例如 **hash** )或数据字段(例如 **owner** $^{id}$( *α* ))，数据类型标记使用大写名称标记，以 **Tag** 开头的数据类型简写为 **Tag** $(arg_1, . . . , arg_n)$ ，一系列的数据类型 $(D_1, . . . D_n)$ 写作 $\widetilde{D}$ 。

### 2.4 微链

<a name='Section2.4'>Linera</a>基础设施的主要构建单元称为微链。微链(或简称*链*)与常规区块链并无二致，都由一系列包含交易的区块组成。值得指出的是，Linera将创建新区块(链所有者角色)从验证区块(验证者角色)中剥离(译者注：现有的区块链系统中，矿工既创建区块，也验证其他矿工创建的区块，因此既是创建者，也是验证者)。向微链添加区块的协议是可配置的，并取决于链的类型（译者注：此处指微链可以是单所有者，也可以是多所有者，因此微链创建区块的角色实例可以是一个，也可以是多个，取决于创建微链的时候创建者的配置和微链的类型）。

**微链标识**。每一条微链具有一个不可重放的*id*。具体来说，*唯一标识符*(或简称*标识符*，*id*)是一串非空数字，记为*id* = [ $n_1$, . . . , $n_k$](1 ≤ *k* ≤ $k_{max}$)。符号 :: 表示将一个数字连接到序列的尾部：[ $n_1$, . . . , $n_{k+1}$] = [ $n_1$, . . . , $n_k$] :: $n_{k+1}$ (*k* < $k_{MAX}$)，在这个例子中，我们将*id* = [ $n_1$, . . . , $n_k$]称为id :: $n_{k+1}$的*父标识符*。

Linera系统的创世配置，其中包含一组固定的微链，随系统启动开始运行。如要创建新的微链，现有微链的所有者需要执行一条创建微链的交易(译者注：Linera启动包含一组公开微链，这一组公开微链与普通的公链并无二致，其区块由验证器产生，因此第一个新用户创建除了公开链的第一条微链时，该用户向公开链发送创建微链交易，验证器创建区块包含该交易并执行，第一条微链即创建成功。与官方就“第一个用户该如何创建第一条微链”话题进行讨论，其结论与其他质押公链的冷启动没有不同，创世配置中将包含某些预先分配了币的地址，例如交易所地址、初始验证器质押地址等，当用户向交易所购买币，交易所将币转账到用户地址，即创建了新的临时微链)，新的微链标识符由父链(执行创建微链交易的链)标识符和创建新链的交易序号相连接得到。

**微链类型**。Linera支持三种类型的微链：

- (**i**) *单所有者链* 只有一个用户(由其公钥标识)可以创建区块；

- (**ii**) *许可链* 只有明确定义的协作用户集合可以创建区块；

- (**iii**) *公开链* 验证者创建区块。

上述三种情况下，验证者对于微链的下一个区块*B*达成共识，都记为证书*C* = **cert**[*B*]。单所有者微链的情况下，证书*C*的创建受可靠广播的启发[7,12]，该部分将在第<a href='#Section2.8'>2.8</a>节中详细阐述。对于公开链，证书*C*是验证者之间的经典BFT共识证明。许可链和公开链将在第<a href='#Section2.9'>2.9</a>节中作概要阐述。简单起见，若无特别说明，后文的重点将主要集中在单所有者链上。

每条微链都包含**owner**$^{id}$(*α*)字段，如果该微链有所有者(译者注：公开链由验证者出块，可能没有所有者)，**owner**$^{id}$(*α*)字段字段将用于验证其*owner(s)*(所有者)。我们用**owner**$^{id}$(*α*) = *pk*记录单所有者的公钥为*pk*的微链，许可链记作**owner**$^{id}$(*α*) = { ${pk}_1$, . . . , ${pk}_n$}，公开链记作**owner**$^{id}$(*α*) = &#x2605;。如果**owner**$^{id}$(*α*) = ⊥，表示该微链处于*非活跃*(*inactive*)状态。

**微链生命周期**。运行中的微链可以为另一个用户创建新微链，并使用区块证书*C*作为创建证明(译者注：即该创建微链的交易被打包到证书*C*描述的区块*B*中)。新微链被创建后，与父链的运行是相互独立的。Linera设计了一条专用的公开链，以方便新用户创建他们自己的第一个微链。

Linera也可以通过执行交易更改**owner**$^{id}$(*α*)，将微链的控制权(译者注：主要为微链出块权)安全可靠地转移给另一个用户。当设置**owner**$^{id}$(*α*) = ⊥生效，微链将永久停用。

微链的唯一标识符具有重要意义。当微链被停用时，微链的状态可以安全地删除并存档在冷存储，唯一标识符使得这些存档的区块数据不能用于重放攻击(TODO：确认用ID防止重放攻击的场景)。

**区块**。一个*区块*可以用数据类型*B* = **Block**(*id*, *n*, *h*, $\widetilde{T}$)描述，其中：

- *id*表示该区块所属微链的唯一标识符，

- *n* ≥ 0表示微链区块高度，

- *h*表示上一个区块的哈希值(如果*n* = 0, *h* = ⊥)，

- $\widetilde{T}$表示一系列*交易*。

交易*T*指一条将在链上执行的指令，区块链的执行状态变更通常由交易完成。在Linera中，交易除了字面意义，通常还包含创建微链、发送消息到目标微链，或接受消息等。

当验证者收到一个包含*id*和下一个预期区块高度*n* + 1的证书*C* = **cert**[*B*]时，区块*B*即被添加到标识符为*id*，包含区块⊥ → $B_0$ → . . . → $B_n$的微链上。验证者集合追踪每条微链的当前状态，当区块*B*的区块链接正确性、执行正确性被验证通过，验证者集合将投票向微链添加区块*B*。在BFT前提下，我们能够确保验证者在每条微链上将最终执行相同的区块序列，然后达成一致的执行状态。

区块 B 的执行包括按照给定顺序解释 B 中列出的交易。交易可能会为其他链产生输出消息并消费输入消息。在实践中，出于审计目的，区块 B 还包括执行该区块后的状态哈希值，以及交易产生的输出消息。

### 2.5 跨链请求

<a name='Section2.5'>为了</a>扩展性，Linera应用程序的状态通常分布在许多微链上，并依赖异步通信进行跨链协同(亦见第<a href='#Section4.3'>4.3</a>节的可编程性)。

在协议层面，微链之间的异步通信依赖于称为*跨链请求*的重要机制实现。具体来说，当验证者*α*执行微链*id*上的一条交易，该交易需要修改另一条微链 $id'$ 的状态，将会触发一次异步交互。(跨链请求的伪代码参见Algorithm 1。) 跨链请求简单实现为验证者内网的远程过程调用(RPCs)：这样的实现只需要确保每次请求只执行一次。(译者注：英文文档使用cheaply implemented，描述复用RPC实现的低成本和便捷性)。

需要做出特别说明的是，鉴于验证者之间对于跨链请求的执行顺序不可能达成一致(译者注：由于跨链请求为验证者之间的RPC调用，不同验证者并不能确保RPC请求的顺序完全一样)，我们不能通过任意跨链请求修改目标链的执行状态，这样会破坏安全性。FastPay<a href='#References7'>[7]</a>中的跨链请求只用于实现支付，在Linera中，这样的机制(译者注：指跨链请求)也用于创建新微链，和向运行中的微链的*收件箱*传输消息。

由于收件箱的消息不会立即在目标微链执行，收件箱允许Linera支持任意消息。可以这么说，目标微链的收件箱中，消息实现为一个可交换的数据结构(即插入顺序无关)，该数据结构将在第<a href='#Section2.6'>2.6</a>进一步阐述。目标微链的所有者(们)从收件箱中取出消息，执行交易以修改微链状态(<a href='#Section2.7'>2.7</a>节)。

### 2.6 微链状态

<a name='Section2.6'>本小节</a>我们将从验证者和客户端的角度阐述Linera微链的状态。每个验证者都会存储一个由微链的标识符索引的微链状态映射表，该表中包含全部微链。客户端与验证者唯一不同的是，客户端只存储与自己相关的微链子集，每个客户端都相当于其微链子集的*全节点*(即追踪微链区块与执行状态)。接下来，我们将重点阐述给定验证者*α*的状态。

**链状态**。验证者*α*看到的微链*id*可以分为两部分：(i) *一致部分*，该部分为验证者*α*已经执行过的微链区块⊥ → $B_0$ → . . . → $B_n$；(ii) *本地部分*，验证者集合在该部分上可能不能达成共识。一致部分的链状态包含以下数据：

- **owner**$^{id}$(*α*)，前述控制微链*id*的区块创建的链所有者，

- **next-height**$^{id}$(*α*)，记录微链*id*下一区块高度的整数值($n + 1$，初值为0)，

- **block-hash**$^{id}$(α)，上一个区块的哈希值**block-hash**$^{id}$(α)（初值为⊥），

- **state**$^{id}$(*α*)，执行状态**state**$^{id}$(*α*)。

本地化部分的链状态包括以下内容：

- **pending**$^{id}$(*α*)，可选值，表示微链*id*上正在等待确认的区块(初值为⊥)，

- **received**$^{id}$(*α*)，证书列表，追踪目标微链*id*的所有已经被验证者*α*确认的证书，

- **inbox**$^{id}$(*α*)，*收件箱*数据结构(见下一段)。

**pending**$^{id}$(*α*)字段只对单所有者链生效，我们将在第<a href='#Section2.8'>2.8</a>节中阐述，许可链和公开链的情况将会由额外的数据进行补充，而**received**$^{id}$(*α*)证书列表对于可用性(第<a href='#Section3.3'>3.3</a>)至关重要。

**收件箱状态**。收件箱 $I = {inbox}^{id}(α)$ 是一种特殊数据结构，用于追踪微链 *id* 接收的跨链消息，并等待消息被交易消费。特别地，接收消息时将消息 *添加* 到收件箱中，目标链执行消息后从收件箱中移除。

收件箱的一个重要特性时添加或消费不同的消息顺序是可交换的。在最简单的实现中，我们可以将收件箱看作两个不相交的消息集合 $I = (I_+, I_−)$ 。我们可以将添加消息 *m* 到 *I* 中的操作定义为 $I + m$ ，如果 $m \notin I_−$ ，则 $(I_+, I_−$\\{m})，否则 $(I_+ ∪$ {m}。(译者注：此处数学公式表示 *I* 集合中的两个子集中只要由一个子集添加过消息 *m* ，则不在将消息 *m* 添加到 *I* 集合)。同样，将从 *I* 中移除消息 *m* 的操作定义为 $I − m$ ，如果 $m \notin I_+$ ，则 $(I_+$\\{m}, $I_−)$ ，否则 $(I_+, I_− ∪$ {m})。在这种情况下，对于 ${inbox}^{id}(α) = (I_+, I_−)$ ，集合 $I_+$ 表示微链 *id* 已经接受并将在下一个区块中执行的消息m； $I_−$ 表示那些尽管尚未被微链 *id* 接收(验证者 *α* 的视角)，但预期将被已经认证的区块执行的消息。在这个简化的描述中，由于消息包含发送方和接收方 $(id, id')$ 的计数器，我们假设消息永远不会被无差别重放。

Linera的当前实现使用了一种更复杂的数据结构，对于每对发送者和接收者以及每个应用程序，该数据结构强制有序地传递消息，附录A.1对此做了详细的阐述。简单起见，后文中我们仍然使用符号 ${inbox}^{id}_−$ 来代替前述集合 $I_−$ ，表示那些特定时刻已经被执行却尚未被微链 *id* 收到的的消息。

### 2.7 区块执行

<a name='Section2.7'>本小节</a>我们将阐述如何执行区块交易。Linera支持如下的交易类型：

- $OpenChain(id', pk')$，用户 $pk'$ 创建新的微链 $id'$ ；

- $ChangeKey(pk')$，转移微链的所有权；

- $CloseChain$，停止微链*id*；

- $Execute(o)$，执行*用户操作o*；

- $Receive(m)$，从收件箱中取出一条*跨链消息m*并执行。

前三种交易类型是在协议中预先定义的*系统操作*，相反，用户操作*o*是由用户定义的应用程序(也称为“智能合约”)执行。概而言之，区块创建者应该可以自由添加操作，而消息应由另一微链的另一交易发起，然后才能被接收(2.5)。

简单起见，我们省略了多所有者链和重新配置所需的交易费用和额外逻辑(第<a href='#Section2.9'>2.9</a>节)。正式地说，为了执行用户操作o，我们假设有一个记为 $ExecuteOperation(id, o)$ 的方法，该方法试图修改 ${state}^{id}$，如果修改成功，该方法可能返回⊥或 $(m, id')$，二者只有在需要向微链 $id'$ 发送一条消息*m*的时候才返回。我们还假设一个方法 $ExecuteMessage(id, m)$，该方法通过执行一条跨链消息 *m* 修改 ${state}^{id}$ 。特别需要指出的是，接收一条m消息可能会产生另一条消息 $m'$ 作为回应。

上述内容对应Algorithm 1中伪代码，其中执行区块 $B = Block(id, n, h, \widetilde{T})$ 对应函数ExecuteBlock。验证区块的函数BlockIsValid执行过程与ExecuteBlock相似，除了执行结果不持久化(因而不会影响链状态)、忽略跨链查询、以及消息不能预先执行，也就是说，如果调用结束时 ${inbox}^{id}_-$ 非空，验证将失败。

### 2.8 客户端/验证者交互

<a name='Section2.8'>本小节</a>我们阐述在Linera系统中客户端(又称为链所有者)与验证者之间的交互。遵循Linera协议的客户端运行一个本地节点，记为β，追踪与其相关的微链子集，该子集通常包含客户端拥有的链以及这些链的依赖。除此之外，该节点也追踪一条特殊的Admin公开链。Admin公开链负责维护验证者集合，以及验证者的网络地址(第<a href='#Section2.9'>2.9</a>节)。

和验证者的网络交互总是从客户端发起，这些交互的目的主要为(i)向自己维护的微链添加一个新区块，或(ii)将自己维护的微链的证书提供给*滞后*的验证者。

验证者实现了两个服务处理例程(称为 HandleRequest 和 HandleCertificate)支持上述两种场景，Algorithm 2中描述了该过程。简单起见，我们省略了客户端从验证者查询连状态或同步区块链的处理例程。

首先我们讨论更新滞后验证者的交互。

**向验证者上传缺失证书**。对于处于活跃状态的微链 *id*，以及验证者 *α* 认为符合下一个预期高度的区块 $B = Block(id, n, h, \widetilde{T})$ (正式写法记作 ${owner}^{id}(α) \not= ⊥$ and **next-height**$^{id}(α) = n$ )，任何客户端都可以使用HandleCertificate将新证书 $C = cert[B]$ 上传到验证者提交给验证者 *α* 。

如果验证者 *α* 尚未创建链 *id* ，或者滞后超过一个区块高度，客户端应该顺序上传多个缺失的证书，并以 $C = cert[B]$ 结尾。若有必要，该证书序列可以从 *祖先* 微链 $id'$（即 $id' = parent(parent(. . . id))$ ）的区块开始。此时，上述区块序列应该包含验证者验证者所能管理的最后一个父链之后的所有父链区块，并直到 *C* 所在微链的区块结束。

实际上，要求客户端上传这样一个区块序列，也表明本地节点 *β* 是第一个能够追踪微链 *id* 的角色。客户端可以通过查看列表 ${received}^{id}(β)$ 中记录的第一个区块来快速找到创建 *id* 的确切区块。

**扩展单所有者链**。如图1所示，当执行状态同步正常的验证者足够时，Linera客户端可以通过一种可靠广播的变体[<a href='#References7'>7</a>, <a href='#References12'>12</a>]，向他们的微链添加一个新的区块*B*。该过程步骤如下：

- 客户端将其签名验证的区块*B*通过HandleRequest广播给每个验证者，并等待一定数量的回复；

- 对于 *有效* 请求 $R = auth[B]$ ，验证者在预期高度向客户端发送签名 *B* ，称为 *投票* ，作为回应(&#x2462;)。客户端收到一定数量的投票后，生成一个证书 $C = cert[B]$ ；

- 客户端向验证者上传(&#x2463;)下一个区块高度的证书 $C = cert[B]$ ，此时亦将触发区块 *B* 的一次执行(&#x2464;)。

当某个验证者 *α* 不能立即确认一个有效(译者注：otherwise-valid应该怎么翻译？)区块提议 $B = Block(id, n, h, \widetilde{T})$ 时，首先需要执行同步(&#x24EA;)。以下两种原因可能导致这种情况发生：

![image](https://github.com/kikakkz/linera-whitepaper/assets/13128505/46ef58c9-a9f0-40b7-ac8e-bfe704e36699)
 
- 1. 微链 *id* 处于停用状态，或验证者 *α* 缺少较早的区块(即 ${owner}^{id}(α) = ⊥$ or **next-height**$^{id}(α) < n$ )；
 
- 2. 验证者 *α* 缺失跨链消息，即当 $\widetilde{T}$ 阶段性执行结束时， $I_− = {inbox}^{id}$ 不为空。

第一种情况下，如前所述，Linera客户端必须按照前述方法上传微链 *id* (可能包含其祖先链)的全部缺失证书，直到 **next-height**$^{id}$(α) = n 。第二种情况下，由于微链 *id* 缺失跨链消息 $m ∈ I_−$ ，客户端必须向微链 *id* 上传消息发送链的缺失证书。当区块 *B* 被正确构造(即没有尝试接收未发送的消息)，证书集合 $\cup_α' {received}^{id}(α')$ ( $α'$ 为任意数量的验证者)必定能够覆盖集合 $I_−$ 中的消息。

需要特别指出的是，所有客户端都能从向验证者上传缺失区块这一行为中受益。为了最大限度提升可用性与降低交易延迟，实现上，当涉及到自己拥有的微链时，用户们常倾向于主动更新所有验证者，以减少从其他客户端同步的需要。然而，每个人都可能进行同步对于可用性来说至关重要(第<a href='#Section3.3'>3.3</a>节)，这也使得证书能够作为验证区块的最终证明。

实现上，客户端应该在单独的线程上执行每个验证者的同步步骤(&#x24EA;)(可选)和投票步骤(&#x2460;)。一旦收到足够的投票(&#x2461;)，客户端可以停止与验证者之间的同步，以防止恶意验证者发起的拒绝服务攻击。

单所有者链中，确定新区快的步骤&#x2460;&#x2461;&#x2462; 将消耗1.5个RTT(译者注：指通信的往返时间)。收到可靠广播启发，这个协议没有“试图变更”的概念<a href='#References12'>[12]</a>来支持重试，换句话说，只要有验证者开始针对区块*B*投票，链所有者不能中断当前区块*B*的提交，转而创建一个不同的区块。如果链所有者这么做，那么他的微链将被阻塞。有鉴于此，Linera也支持另一种可靠广播的变体，该变体将消耗额外的一个RTT(第<a href='#Section2.9'>2.9</a>节)。

### 2.9 核心协议的扩展

<a name='Section2.9'>本小节</a>我们介绍一些Linera核心多链协议的重要扩展。

**许可链**。<a href='#Section2.8'>2.8</a>节介绍了在单所有者链上添加区块的乐观协议，该协议消耗1.5个客户端到验证者的RTT。为了适应下述应用场景，Linera使用一种更加复杂的协议，该协议消耗2.5个RTT：

- 单所有链的所有者希望能够安全地终端进行中的区块提议；

- 区块中的交易依赖于外部预言机(例如Unix时间)，并且某些条件在区块被验证之后变得无效；

- 多个所有者希望共同运营微链(假设这些所有者之间具有一定的链下协作水平)；

- 单所有者链的所有者希望委托验证者重新配置有关的维护操作。

简洁起见，我们省略了2.5个RTT的区块验证协议的细节。该协议可以认为是一个简化的部分同步BFT共识协议<a href='#References12'>[12]</a>，其中包含视图变更(亦称为轮次)，但不包含领导者选举或超时机制。当没有领导者选举时，同一时刻(例如在同一个区块高度和轮次)不同的所有者将会尝试提交不同的区块，进而导致当前轮次失败，需要在新的轮次中重新达成共识。因此，这种操作假定同一链的不同所有者保持足够水平的(链下)合作，从而保证最终只有一个用户提出区块并成功提交。

**公开链**。当微链的区块由验证者创建时，我们将其称之为公开链。此时，区块中的交易可能只包含其他微链发送的跨链消息。公开链的应用场景包含：

- 在同一个地方管理验证者和质押份额(参见后文的重新配置)；

- 运行一些不是为多链应用设计的传统区块链算法(例如AMMs(译者注：自动做市商))；

- 帮助新用户创建微链。

Linera的公开链基于完整的BFT公式协议。在Linera基础设置中，当且仅当微链为公开链时，验证者将创建微链的新区块。传统区块链使用内存池(mempool)搜集新区块的候选交易，Linera将使用用户微链和跨链消息代替内存池完成同样的功能。

**发布/订阅频道**。微链*id*上的应用程序实例创建一个频道，并维护订阅者列表，这是跨链异步消息的常见用例。具体而言，频道按照如下方式运作：

- 微链*id*上执行的交易可能向频道推送新消息；

- 此时，将有一条跨链消息被发送到当前订阅者(们)的收件箱；

- 微链*id*通过接收并执行订阅者 $id'$ 发送的 $Subscribe(id')$和 $Unsubscribe(id')$ 消息管理订阅者集合。

我们已经发现在编写Linera应用程序时，发布/订阅频道时一个有用的抽象(也见第<a href='#Section4'>4</a>节)。Linera协议原生支持发布/评阅频道使得我们可以实现特定的优化。例如，无需链所有者做任何额外工作，新加入的订阅者便将收到频道的最后一条消息。

**重新配置**。有能力变更Linera的验证者集合(也称为委员会)对于系统安全性至关重要(见第<a href='#Section5'>5</a>节)。

为此，Linera原生部署了一个专用的Admin公开链，该链用于运行系统管理应用。系统管理应用负责追踪连续的验证者集合(译者注：原文用successive sets of validators)，即*委员会*，包括验证者的质押份额和网络地址。系统管理应用产生的不同配置通过*纪元*进行标识。

Admin公开链将新配置发布到特定的频道，所有Linera微链在创建时都会订阅该频道，这样验证者集合的变更就能够安全地传播给所有参与者。 $^{2}$ 新创建的微链将自动收到当前验证者集合(即管理频道中的最后一条消息)，并设置其当前*纪元*。

如果创建了新的委员会，每条微链都将在其收件箱中收到一条消息。需要特别指出的是，微链所有者必须将创建委员会的新消息添加到新的区块，明确标识他们的链将迁移到新的验证者集合上。该操作必须新旧两组验证者都在同时执行，且旧验证者停止执行之前完成。

得益于Linera的可伸缩性，只要拥有足够多的活跃客户端，并行将大量的微链迁移到新的配置是可行的。为了简化该过程，并考虑到链所有者可能需要额外的离线时间，我们认为许多用户将倾向于授权第三方角色代表他们创建迁移块。在这种情况下，在授权期间，需要配置微链使用前文提到的2.5个RTT的协议。

为了防止长程攻击，Admin公开链将定期提议*废除*旧委员会。当旧委员会被废弃后，微链将忽略仅由旧委员会认证的区块消息，在新的可信委员会(因此导致重新认证)认证的区块重新包含这些旧消息后，这些消息将重新被处理和确认。

## 3 多链协议分析

<a name='Section3'>本章</a>我们将分析Linera区块链的设计目标，包括响应性、扩展性与安全性保证。

### 3.1 响应性

传统区块链交互的常见问题是缺乏性能保证。提交到内存池的交易可能立即被选中，或一段时间后被选中，也可能永远不会被选中，其结果取决于其他用户在同一时间提交的交易。如果需要取消待处理的交易，通常需要以更高的gas费用创建一条新交易。此外，传统区块链的TPS是固定且有限的：大量突发提交的交易(例如热门空投)将最终导致消息积压，和/或交易手续费激增。由于MEV(Miner Extractable Value)技术，内存池系统也让用户面临价值流失的风险。

收到基于客户端的可靠广播协议启发，Linera允许用户管理自己的链，并且使用一种轻量级的区块扩展协议解决这些问题。该方法不需要内存池，用户直接向验证者提交交易，并可以完全控制交易处理时间。客户端与验证者之间的并发通信意味着交易的处理延迟仅来自于客户端和验证者之间的网络传输RTT(通常为几百毫秒)。最后，我们预期移除内存池、降低延迟将大大减少MEV机会。

### 3.2 可扩展性

微链的应用(第<a href='#Section2.4'>2.4</a>节)使得Linera验证者可以在多个工作节点之间高效地进行分片。具体而言，验证者的每个工作节点负责处理特定的微链子集。客户端与验证者的负载均衡器通信，负载均衡器将请求转发给相应的内部工作节点(图2).

![image](https://github.com/kikakkz/linera-whitepaper/assets/13128505/a7654bf4-7c6b-4b90-8bcd-0a8e3b485c69)

这样的设计使得Linera在系统负载增加时可以水平扩展：验证者只需要增加内部工作节点应对流量。需要特别指出的是，分片是验证者的内部工作：这意味着验证者的工作节点数量，以及每个工作节点的微链分配方式在不同的验证者之间并不需要保持一致。

验证者的工作节点从属于单一运营商，因此工作节点之间彼此互相信任。因此，工作节点之间的通信——即Linera的跨链请求(第<a href='#Section2.5'>2.5</a>节)——是快速而廉价的。

Linera的分片模型与大家熟知的区块链分片方法[<a href='#References31'>31</a>, <a href='#References33'>33</a>]不同，后者的跨链消息发生在相互不信任的节点组(即分片验证者)之间，这些节点组通常分布在互联网上，因而会造成显著的开销。Linera的跨链消息由相互信任的工作节点点对点完成，开销更小。这样的实现，也使得那些想控制其操作的客户端可以对大的验证者进行高效审计，我们将在第<a href='#Section5'>5</a>节中介绍审计操作。

在Linera的弹性架构下，验证者可以适应流量波动。当提交的交易数量增加，验证者很容易增加处理交易的云端工作节点；反之验证者可以快速关闭工作节点以降低成本。

Linera的*公开链*中，不同客户端提交的区块遵循完整的BFT协议达成共识(第<a href='#Section2.9'>2.9</a>节)，对于多条*公开链*而言，共识协议的实例化发生在每条公开链，而不针对整个系统。这样的设计有很多好处。首先，不同公开链的用户不会降低彼此的使用体验；其次，单条微链的TPS不会成为整个系统的限制因素；最后，通过创建新的微链并增大单个验证者的规模(译者注：考虑到BFT协议增加验证者数量到一定级别，将可能会降低共识达成的效率，此处应指在添加验证者的工作节点)，Linera的TPS总是可以提高的。

### 3.3 安全性

<a name='Section3.3'>本小节</a>我们将初步分析Linera多链协议的安全性。第<a href='#Section2'>2</a>章的阐述我们侧重于单所有者微链，后文中的分析我们将会扩展到其他类型的微链。

**声明1**(安全性)。*对于任何微链，每个验证者都能看到(同一个前缀)的相同区块序列，因此验证者以相同的顺序修改微链状态，并最终向其他微链提交相同的消息。*

当然，根据Algorithm 2，在给定区块高度，每个诚实的验证者最多给每条微链的一个有效区块投票。根据quorum交集特性(第<a href='#Section2.2'>2.2</a>节)，在BFT前提下，一组验证者针对一条微链只能认证一个区块。从微链中发出的消息(Algorithm 1中的跨链请求)是当前区块序列的确定性函数。

需要特别指出的是，异步跨链消息在调度后仅传递一次，应用因此可以安全地转移资产。

**声明2**(链的最终一致性)。*只要一个诚实的验证者认证了新的区块，其他用户总是可以通过一系列步骤确保该区块被添加到每个诚实的验证者的链上*。

事实上，每个用户都可以从诚实的验证者那里检索新的证书及其祖先，并将其提交给那些尚未接收到这些证书的验证者。第<a href='#Section2.8'>2.8</a>节中我们已经讨论过向验证者上传区块的确切顺序。

**声明3**(异步消息的最终一致性)。*只要一个诚实的验证者上的某条微链收到一条跨链消息，任何用户都可以通过一系列步骤确保该消息被其他诚实的验证者上的微链接收*。

微链通过某些交易触发异步消息，当且仅当触发异步消息的交易被一定数量的验证者验证，并添加到发送者的微链，异步消息才会被特定的验证者的链接收。此时，接收链将更新其状态以追踪消息来源(**received**$^{id}(α)$，第<a href='#Section2.6'>2.6</a>节)。这样的设计允许客户端在需要时从同一验证者下载相应区块，第一次添加该区块(译者注：指包含触发跨链消息交易的区块)的诚实验证者会将跨链消息添加到接收链的收件箱。

**声明4**(真实性)。*只有微链的所有者(们)才能向微链添加区块*。

诚实的验证者仅在区块被链所有者认证之后才接收区块(Algorithm 2)，以确保链所有者外的角色不能向微链添加区块。其他类型的微链(第<a href='#Section2.9'>2.9</a>)也实现了同样的验证。

**声明5**(分段审计)。*我们拥有足够的公开密码学证明，确保Linera的每条微链状态都可以分布式地进行正确性审计*。

每一个Linera客户端都可以请求任何微链的副本并重新执行认证过的区块，这样就可以验证微链的连续执行状态和发送过消息集合。不同的验证者通常通过区块中包含的执行执行哈希比较执行状态，而微链收到的消息则应该与发出消息的链进行比较(第<a href='#Section5.2'>5.2</a>节)。

**声明6**(最坏情况效率)。*在单所有者链中，拜占庭验证者不应给合法用户的区块创建和确认带来显著延迟*。

Linera客户端并发联系所有验证者，一旦客户端收到一定数量的验证者签名，即将操作视为已完成(第<a href='#Section2.8'>2.8</a>节)。

**声明7**(单一区块验证)。*在单所有者链中，在给定高度，只要有诚实的验证者接受了链所有者签名的区块提议，那么通过适当的操作，链所有者最终一定能成功搜集到足够的投票来创建证书*。

![image](https://github.com/kikakkz/linera-whitepaper/assets/13128505/d8aea5cc-67c6-440b-bbb1-b9d457b96c8a)

假定微链 *id* 区块提议 *B* 是某高度的第一个签名区块，当一个验证者接受该区块时，意味着其他验证者 *α* 要么已经接受该区块(即 ${pending}^{id}(α) = B$ )，要么还未进行投票(即 ${pending}^{id}(α) = ⊥$ )。针对后一种情况，验证者 *α* 对于区块 *B* 的验证可能因为早期区块或消息缺失而失败：这种情况可以通过向该验证者上传缺失区块解决(参见第<a href='#Section2.8'>2.8</a>节)。同步完成后，在没有外部预言机和非确定性行为的情况下，验证者 *α* 将最终给提交的区块*B*产生期望的投票。

## 4 在Linera上构建 Web3 应用

<a name='Section4'>Linera</a>的编程模型<a href='#References30'>[1]</a>旨在为应用程序开发者提供丰富的、语言无关的组合性，使得应用开发者可以利用微链的扩展性。

### 4.1 创建应用

Linera采用WebAssembly(Wasm)[<a href='#References3'>3</a>, <a href='#References23'>23</a>]作为应用执行引擎，早期的SDK将基于Rust语言提供。

应用程序的创建分为几个步骤(图3)。首先，将Rust编写的软件模块(又称智能合约)编译成Wasm字节码，应用的作者将字节码部署到某一微链，产生唯一的*字节码标识符*；其次，使用字节码标识符和特定的应用程序参数(例如代币名称，代币供应量等)初始化字节码，这一步骤将创建一个新的应用程序标识符(图3中的“APP 1”)，并初始化应用程序的本地状态(“APP INSTANCE $1_B$”)，应用程序的本地状态可能包含特定参数，将来用于管理新的应用程序。

同一个字节码标识符可以创建多个独立的应用程序，这些应用程序共享相同的代码，单拥有独立的配置(图3中的“APP 1”和“APP 2”)。

![image](https://github.com/kikakkz/linera-whitepaper/assets/13128505/4b5b2b92-3439-4a08-9eef-685e81534547)

### 4.2 多链部署

Linera应用程序默认是多链的，其状态通常分布在几条微链上。换句话说，应用程序在给定微链上的实例指管理该应用程序在给定微链上的状态子集。例如，在类似ERC-20的代币管理应用中，单所有者链的所有者可能希望在他们子集的微链上持有他们的个人账户。

当微链的所有者首次接收来自应用(译者注：指该微链此前并没有运行过发送该消息的应用)的消息时(参见第<a href='#Section2.5'>2.5</a>节)，应用程序的字节码将被自动下载，并开始运行(图3中的“APP INSTANCE”)。

### 4.3 跨链通信

<a name='Section4.3'>应用</a>之间的跨链通信通过异步调用实现，因此不同的微链可以独立运行。Linera应用程序之间的跨链协作编程风格收到actor设计模式的启发，其实现依赖于第<a href='#Section2.5'>2.5</a>节介绍的跨链请求，核心在于每个actor都独占访问其内部状态，且actor之间不能互相调用。

**跨链消息**。跨链消息允许应用程序将任意数据从一条微链异步传输到另一条微链(图4)，跨链消息的发送端和接收端必须是相同的应用程序(译者注：是应用程序，而不是应用程序实例)，这样才能解析发送的数据。实践上，应用程序为每个消息源维护一个收件箱，当应用程序希望向目标发送信息，应用程序只需返回包含消息内容的值，之后运行时将会执行适当的跨链请求。

与FastPay <a href='#References7'>[7]</a> 和 Zef <a href='#References8'>[8]</a> 不同，除了支付请求，Linera可以传送任意用户应用定义的跨链消息。跨链消息的执行结果通常不可交换，因此在Linera中，接收方接收和执行微链的顺序至关重要。通过区块创建者指定的提取消息顺序，我们可以解决此问题。

总而言之，接收端并不保证取出消息，但当消息被取出时，当前的实践将强制按顺序提取消息。为适应特定的使用场景，这一通用策略可能会在将来进一步完善，特别时对于区块生产从不停止的公开链而言(第<a href='#Section2.9'>2.9</a>节)。

**发布/订阅频道**。除了一对一通信，Linera还支持使用*频道*进行一对多通信。用户可以在应用内创建一个频道，运行在其他微链上的同一应用程序的实例可以通过发送包含微链标识的订阅消息订阅该频道。需要特别指出的是，只有当频道发布者将订阅请求消息添加到自己的微链，已接受该订阅后，订阅者才会被添加到频道。底层实现上，频道以一组一对一连接的方式存在，发布到频道的消息将被被提交到所有订阅者的收件箱，并可以被订阅者接收。设计上，新加入的订阅者将只会接收到频道的最后一条消息，而非全部历史消息。

### 4.4 局部可组合性

**同步调用**。运行在相同微链上的不同Linera应用可以通过与经典区块链(如以太坊<a href='#References32'>[32]</a>)中的智能合约调用一样的同步调用进行通信(参阅图4的顶部部分)。单个用户的一系列应用程序调用产生的状态修改是原子的，换句话说，这些调用要么全部成功，要么全部失败。调用一个应用实例将会创建该应用的内部状态的虚拟副本，并在状态缓存上执行该应用，此时，新的状态尚未写入存储，如果任何事务失败，所有暂存的修改将被丢弃。

**会话**。某些场景下，我们希望将一个状态片段的管理委托给另一个应用程序，管理前述分离状态的临时对象称为*会话*。一个可能的典型用例如下：(i)应用B调用代币管理应用A；(ii)提取A账本中的一些代币并放入一个新会话；(iii)B接收该会话的所有权；(iv)B调用该会话将代币存入代币管理应用A的另一个账户，这一操作实际上消费并终结会话。

会话将确保只从属于一个应用程序(没有重复的会话)。会话的消耗是强制性的：会话必须在交易结束前被正确消费，否则交易将失败。除了资产，会话也适用于管理临时合同，例如偿还闪电贷<a href='#References25'>[25]</a>。

### 4.5 用户认证

应用程序通常需要验证终端用户身份，以便授权某些操作。例如，转移资产应该需要所有者许可。

在Linera中，当用户在其拥有的微链上提议一个新区块时，用户将被认证(见第<a href='#Section2.8'>2.8</a>节)。当区块执行时，区块的签名者，称为*authenticated signer*，对于区块中的所有操作都是默认可见的。

创建跨链消息的操作可以选择性地将当前的authenticated signer与消息一起传递，临时存放在另外一条微链(比如公开链)的资产可能需要由所有者来取回。

同样，当调用同一微链上的另一个应用时，authenticated signers也可能被传递，这样应用可以创建新资产，并通过抽象API接口，使得其他应用可以使用该资产。

### 4.6 临时链

Linera编程模型的另一个特点在于能够创建短生命周期的许可链(第<a href='#Section2.9'>2.9</a>节)，这些短期微链可以用于一些协作松散的用户之间的短期交互。

例如，两个用户可以创建一个微链，以原子方式交换两种资产，该微链将(最多)有两个所有者，其参数将依据交换过程调整。当使用该微链时，两个用户必须将需要交换的资产从各自的主微链转移到共享链上，并由其中一个用户创建一个区块来确认或取消交换。特别需要指出的是，当交完完成，共享微链就会被停用，这样可以防止共享临时微链被添加更多区块，以便于将来归档。

为了优化临时许可链的可用性(第<a href='#Section2.9'>2.9</a>节)，如共识协议所述，操作过程将会与用户权限交互创建区块。例如，上述原子交换的临时链中，只有已经锁定资产的链所有者能提议区块。另一个例子是用于两个用户下国际象棋的临时微链，这一微链中，应用可以决定哪位玩家需要移动，然后更新微链共识，只接受来自所选用户的下一个区块。一个更加贴近现实的国际象棋应用可能还需要包含裁判作为临时链的所有者，这样裁判可以强制执行游戏进展。

## 5 去中心化

<a name='Section5'>Linera</a>鼓励验证者基于云基础设施实现弹性扩展，并从标准生产环境获益。最大化的去中心化依赖两个关键特性得以实现：委托权益证明(DPoS)和社区审计。

### 5.1 委托权益证明

Linera依赖委托权益证明(DPoS)保障系统的长期安全性：验证者的投票权取决于他们在系统中的质押份额，以及终端用户委托给他们的质押份额。用户必须能够变更其委托选择，且验证者必须能够自动加入和离开系统，以便DPoS正确执行。这两种操作都需要一个任意用户都可以提交交易的公开链。针对每条微链，验证者的重新配置也需要一个精心设计的迁移协议。这两种机制在第<a href='#Section2.9'>2.9</a>节中已有简单概述。

代币委托和经济模型将在另外的文件做出更加精确的阐述。由于旧的委员会逐渐腐败<a href='#References17'>[17]</a>，Linera允许微链拒绝来自不再受到信任的委员会的跨链消息(例如支付)(见第<a href='#Section2.9'>2.9</a>节)，以解决长程攻击。

### 5.2 可审计性

<a name='Section5.2'>一般而言</a>，区块链的传统审计方法需要运行一个保存完整交易历史副本的*全节点*，然而，一个高TPS的系统中，全节点需要大量的硬盘空间和CPU资源。假设普通用户(那些使用普通硬件的用户)需要耗费数天甚至数周才能完全审计一个去中心化系统时，社区可能没办法阻止一组不良验证者改变协议。轻客户端<a href='#References14'>[14]</a>可以减少资源使用，但其只检查区块头，并不能提供同等级别的验证。

相较而言，微链的应用使得社区能够持续审计Linera验证者。在Linera中，审计者客户端(第<a href='#Section2.8'>2.8</a>节)相同，只需要追踪一小部分微链子集。鉴于Linera的扩展性依赖于更多的微链而非更大的区块，用户始终可以在普通硬件上实时重放单条微链的执行过程。

我们可以在共享分布式存储(例如IPFS<a href='#References5'>[5]</a>)上建立一个分布式协议，以便Linera社区可以持续验证所有微链。执行微链的区块可以验证执行状态和发出去的消息，执行成功的区块通常应标记为已审计，且应该将发出去的消息在分布式存储中建立索引。客户端必须验证收到的消息确实来自于发送链，以完成微链的验证过程。通过查询这些消息在共享存储中的验证状态，客户端可以完成这一操作。如果客户端发现消息未验证，客户端应该发起验证流程。

## 结论

Linera旨在在互联网规模上提供可预测的性能、响应能力和安全性的第一个多链基础设施，Linera引入了在同一组验证者中运行许多并行链(称为*微链*)的概念，并利用每个验证者的内部网络快速传递跨链异步消息，以达成这一目标。这样的架构有许多优点：

- **弹性扩展**。在Linera中，可伸缩性时通过增加微链数量而非增加区块大小或创建区块的速率达成。每个验证者都可以随时添加和移除处理能力(即内部工作节点)，以维持多链应用的性能标准。

- **响应能力**。受到可靠广播启发[<a href='#References7'>7</a>,<a href='#References12'>12</a>]，Linera使用一种无内存池的共识协议实现单个用户的微链操作，这样的实现降低了区块延迟，因而可以极大提升Web3应用程序的响应能力。

- **组合性**。相较于其他多链系统，低延迟的区块也将给组合性带来极大的帮助：接收者可以通过添加一个新区块来快速回复来自另一条微链的异步消息。

- **链的安全性**。与传统的多链系统相比，在同一组验证者中运行所有微链的好处，在于当需要创建新微链时，Linera的安全模型不会受到影响。

- **去中心化**。Linera依赖于委托权益证明(DPoS)确保安全性，每一条微链都可以在普通硬件上单独执行，客户端和审计者因此可以持续运行自己的验证，以确保验证者是负责可靠的。

- **语言无关**。Linera的编程模型不依赖特定编程语言。经过慎重考虑，我们决定将我们的工作集中在Wasm和Rust上，这两种语言将作为Linera早期的执行层的开发语言。

将来，我们将正式指定支持多所有者链的协议，以及第<a href='#Section2.9'>2.9</a>节中提到的其他扩展。特别地，我们计划在我们现有的多链基础设施上纳入最先进的共识机制(如[<a href='#References16'>16</a>, <a href='#References22'>22</a>, <a href='#References27'>27</a>])，验证者的公平酬金和用户激励经济模型也将单独予以说明。停用与归档微链的能力未将来验证者控制存储成本提供了一个优雅的解决方案。总而言之，我们预期当验证者规模持续增大需要优化成本时，Linera的集成架构与最小化验证者交互将会带来极大的帮助。

<h1>参考文献</h1>
<a name='References1'>[1]</a> Linera developer manual. https://linera.dev.

<a name='References2'>[2]</a> Linera github repository. https://github.com/linera-io/linera-protocol.

<a name='References3'>[3]</a> WebAssembly. https://webassembly.org/.

<a name='References4'>[4]</a> The Bytecode Alliance. https://bytecodealliance.org/, 2022.

<a name='References5'>[5]</a> The InterPlanetary File System. https://ipfs.tech/, 2022.

<a name='References6'>[6]</a> Gul Agha. Actors: a model of concurrent computation in distributed systems. MIT press, 1986.

<a name='References7'>[7]</a> Mathieu Baudet, George Danezis, and Alberto Sonnino. Fastpay: High-performance Byzantine fault tolerant settlement. In Proceedings of the 2nd ACM Conference on Advances in Financial Technologies, pages 163–177, 2020.

<a name='References8'>[8]</a> Mathieu Baudet, Alberto Sonnino, Mahimna Kelkar, and George Danezis. Zef: Low-latency, scalable, private payments. arXiv preprint arXiv:2201.05671, 2022.

<a name='References9'>[9]</a> Sam Blackshear, Evan Cheng, David L. Dill, Victor Gao, Ben Maurer, Todd Nowacki, Alistair Pott, Shaz Qadeer, Rain, Dario Russi, Stephane Sezer,Tim Zakian, and Runtian Zhou.  Move: A language with programmable resources.  https://diem-developers-components.netlify.app/papers/diem-move-a-language-with-programmable-resources/2020-05-26.pdf, 2020.

<a name='References10'>[10]</a> Vitalik Buterin. Endgame. https://vitalik.ca/general/2021/12/06/endgame.html, 2021.

<a name='References11'>[11]</a> Vitalik Buterin. An incomplete guide to rollups. https://vitalik.ca/general/2021/01/05/rollup.html, 2021.

<a name='References12'>[12]</a> Christian Cachin, Rachid Guerraoui, and Luı́s Rodrigues. Introduction to reliable and secure distributed programming. Springer Science & Business Media, 2011.

<a name='References13'>[13]</a> Miguel Castro, Barbara Liskov, et al. Practical Byzantine fault tolerance. In OsDI, volume 99, pages 173–186, 1999.

<a name='References14'>[14]</a> Panagiotis Chatzigiannis, Foteini Baldimtsi, and Konstantinos Chalkias. Sok:Blockchain light clients. Cryptology ePrint Archive, 2021.

<a name='References15'>[15]</a> Philip Daian, Steven Goldfeder, Tyler Kell, Yunqi Li, Xueyuan Zhao, Iddo Bentov,Lorenz Breidenbach, and Ari Juels. Flash boys 2.0: Frontrunning in decentralized ex-changes, miner extractable value, and consensus instability. In 2020 IEEE Symposium on Security and Privacy (SSP’20), pages 910–927. IEEE, 2020.

<a name='References16'>[16]</a> George Danezis, Lefteris Kokoris-Kogias, Alberto Sonnino, and Alexander Spiegelman. Narwhal and Tusk: a DAG-based mempool and efficient BFT consensus. In Proceedings of the Seventeenth European Conference on Computer Systems, pages 34–50, 2022.

<a name='References17'>[17]</a> Evangelos Deirmentzoglou, Georgios Papakyriakopoulos, and Constantinos Patsakis. A survey on long-range attacks for proof of stake protocols. IEEE Access, 7:28712–28725,2019.

<a name='References18'>[18]</a> Ittay Eyal, Adem Efe Gencer, Emin Gün Sirer, and Robbert Van Renesse. {Bitcoin-NG}: A scalable blockchain protocol. In 13th USENIX symposium on networked sys-tems design and implementation (NSDI 16), pages 45–59, 2016.

<a name='References19'>[19]</a> Rati Gelashvili, Alexander Spiegelman, Zhuolun Xiang, George Danezis, Zekun Li,Dahlia Malkhi, Yu Xia, and Runtian Zhou. Block-STM: Scaling blockchain execution by turning ordering curse to a performance blessing, 2022.

<a name='References20'>[20]</a> Arthur Gervais, Ghassan O Karame, Karl Wüst, Vasileios Glykantzis, Hubert Ritzdorf,and Srdjan Capkun. On the security and performance of proof of work blockchains. In Proceedings of the 2016 ACM SIGSAC conference on computer and communications security, pages 3–16, 2016.

<a name='References21'>[21]</a> Arthur Gervais, Hubert Ritzdorf, Ghassan O Karame, and Srdjan Capkun. Tampering with the delivery of blocks and transactions in bitcoin. In Proceedings of the 22nd ACM SIGSAC Conference on Computer and Communications Security, pages 692–705, 2015.

<a name='References22'>[22]</a> Neil Giridharan, Lefteris Kokoris-Kogias, Alberto Sonnino, and Alexander Spiegelman. Bullshark: DAG BFT protocols made practical. arXiv preprint arXiv:2201.05677,2022.

<a name='References23'>[23]</a> Andreas Haas, Andreas Rossberg, Derek L Schuff, Ben L Titzer, Michael Holman, Dan Gohman, Luke Wagner, Alon Zakai, and JF Bastien. Bringing the web up to speed with webAssembly. In Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation, pages 185–200, 2017.

<a name='References24'>[24]</a> Jae-Yun Kim, Junmo Lee, Yeonjae Koo, Sanghyeon Park, and Soo-Mook Moon. Ethanos: efficient bootstrapping for full nodes on account-based blockchain. In Pro-ceedings of the Sixteenth European Conference on Computer Systems, pages 99–113,2021.

<a name='References25'>[25]</a> Krešimir Klas. Smart contract development — Move vs. Rust. https://medium.com/@kklas/smart-contract-development-move-vs-rust-4d8f84754a8f, 2022.

<a name='References26'>[26]</a> Michal Król, Onur Ascigil, Sergi Rene, Alberto Sonnino, Mustafa Al-Bassam, and Etienne Rivière. Shard scheduler: object placement and migration in sharded account-based blockchains. In Proceedings of the 3rd ACM Conference on Advances in Financial Technologies, pages 43–56, 2021.

<a name='References27'>[27]</a> Dahlia Malkhi and Kartik Nayak. Hotstuff-2: Optimal two-phase responsive bft. Cryp-tology ePrint Archive, 2023.

<a name='References28'>[28]</a> Du Mingxiao, Ma Xiaofeng, Zhang Zhe, Wang Xiangwei, and Chen Qijun. A review on consensus algorithm of blockchain. In 2017 IEEE international conference on systems,man, and cybernetics (SMC), pages 2567–2572. IEEE, 2017.

<a name='References29'>[29]</a> nanfengpo. A design of decentralized ZK-rollups based on EIP-4844. https://ethresear.ch/t/a-design-of-decentralized-zk-rollups-based-on-eip-4844/12434, 2022.

<a name='References30'>[30]</a> Slashdot. Best blockchain apis of 2022. https://slashdot.org/software/blockchain-apis/, 2022.

<a name='References31'>[31]</a> Alberto Sonnino. Chainspace: A sharded smart contract platform. In Network andDistributed System Security Symposium 2018 (NDSS 2018), 2018.

<a name='References32'>[32]</a> Gavin Wood et al. Ethereum: A secure decentralised generalised transaction ledger.Ethereum project yellow paper, 151(2014):1–32, 2014.

<a name='References33'>[33]</a> Mahdi Zamani, Mahnush Movahedi, and Mariana Raykova. Rapidchain: Scaling blockchain via full sharding. In Proceedings of the 2018 ACM SIGSAC conference on computer and communications security, pages 931–948, 2018.
